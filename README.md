# ArduinoCar

「ArduinoCar」は、Arduino Unoを用いて車を適切に制御するソフトウェアを開発するプロジェクトです。
このソフトウェアは所属する大学にて行われたライントレース・追従実験の一貫として開発されたものであり、特定のハードウェアに依存する構成となっています。

## 使用ツール

開発フレームワークとしてはPlatformIOを採用しています。プログラムのビルド・実行には事前にPlatformIO環境が必要です。

### 依存ライブラリ

当プロジェクトにおいて利用させていただいた外部ライブラリを以下に紹介させていただきます。

- [bxparks/AceRoutine@^1.5.1](https://github.com/bxparks/AceRoutine)
- [bxparks/AceCommon@^1.5.2](https://github.com/bxparks/AceCommon)
- [thijse/ArduinoLog@^1.1.1](https://github.com/thijse/Arduino-Log)
- [throwtheswitch/Unity@^2.5.2](https://github.com/throwtheswitch/Unity)

## ビルド・実行方法

使用するボードは「Arduino Uno」を想定しています。

### トレースプログラムのビルド＆アップロード

Arduino UnoをPC本体につなげた状態で、以下のコマンドを叩きます。

```sh
pio run -t upload -e trace
```

### 追従プログラムのビルド＆アップロード

Arduino UnoをPC本体につなげた状態で、以下のコマンドを叩きます。

```sh
pio run -t upload -e follow
```

その他pioコマンドの使い方は公式リファレンスを参考にしてください。

## ハードウェア要件

### ピン割当

Arduinoボードの各種ピンはデフォルトで以下の設定になっています。なお、`src`ディレクトリ内のメインプログラムでは実際にピン番号を指定している箇所があるので、そこを手動で書き換えることでも対応可能です。

#### トレース車のピン割当

| 部品名          | ピン設定                                  |
|--------------|---------------------------------------|
| 左モータドライバー    | `plus_pin=4, minus_pin=5, pwm_pin=11` |
| 右モータドライバー    | `plus_pin=2, minus_pin=3, pwm_pin=10` |
| フォトリフレクタ（中央） | `pin=A1`                              |
| フォトリフレクタ（左）  | `pin=A2`                              |
| フォトリフレクタ（右）  | `pin=A0`                              |
| 内蔵LEDランプ     | `pin=13`                              |

#### 追従車のピン割当

| 部品名       | ピン設定                                  |
|-----------|:--------------------------------------|
| 左モータドライバー | `plus_pin=2, minus_pin=3, pwm_pin=11` |
| 右モータドライバー | `plus_pin=4, minus_pin=5, pwm_pin=10` |
| 超音波センサ（左） | `trig_pin=6, echo_pin=7`              |
| 超音波センサ（右） | `trig_pin=9, echo_pin=8`              |
| 障害物検知センサ  | `pin=12`                              |
| 内蔵LEDランプ  | `pin=13`                              |

## ソフトウェアアーキテクチャ

当ソフトウェアは、独自に設計したアーキテクチャに従って開発されています。
はじめに、採用したアーキテクチャの特徴から簡単に紹介します。

- オブジェクト指向に準拠し各種ハードウェアコンポーネントと対応するクラスが定義・実装されている
- `setup`関数でハードウェアに対応する`Car`クラスおよびそれを制御する`CarController`クラスをインスタンス化する。
- `loop`関数ではセンサーの更新と車体制御に注力する。

### オブジェクト指向に基づくクラス・インタフェース設計

#### `Car`クラス※概念

各コンポーネントを束ねるクラスです。渡さなければならない引数を一つにして、プログラムの保守性を向上させます。
コンストラクタで各コンポーネントのポインタを受け取って内部に保持し、メソッド経由でコンポーネントへのアクセスを公開します。
ハードウェアと1対1に対応します。

#### `CarController`インタフェース

車体制御部を抽象化したものです。コンストラクタで制御対象の`Car`クラスのポインタを受け取り、保持。
`Update()`メソッドでセンサ情報を更新し、`Operate()`メソッド内で車体制御を行います。

#### `Motor`インタフェース

モータの制御用メソッドを提供します。

#### `AnalogSensor`、`DigitalSensor`インタフェース

センサの値更新・取得の機能を提供します。`AnalogSensor`はアナログ値を扱うセンサ、`DigitalSensor`はデジタル値を扱うセンサにそれぞれ対応します。

#### その他クラス

用途に応じて様々なクラスを作成しています。一部の例を以下に紹介します。

- `xxDebugger`・・・デバッグ用クラス
- `PhotoReflector`・・・フォトリフレクタを抽象化
- `SonicSensor`・・・超音波センサを抽象化
- `SonicSensorUpdater`・・・超音波センサ更新のタイミング制御クラス
- `PidController`・・・PID制御を抽象化したクラス

### ライフサイクル

#### setup関数

各種コンポーネントの初期化を行います。**インスタンス生成はここでしか行ってはいけません**。グローバル変数にはControllerクラスだけを置きます。
それ以外は基本的にグローバルスコープにおいてはいけません（デバッグ用クラスなどどうしても上に置くしかないものは例外）。

※以下のコードは簡略化したイメージです。実際のものとは一部異なります。

```c++
// コントローラーはloopで使うので一番上に宣言
CarController *controller;

void setup() {
    Car *car = new MyCar(
        new Motor(),
        new Motor(),
        new PhotoReflector(),
        new PhotoReflector(),
        new PhotoReflector()
    );
    controller = new MyCarController(car);
}
```

#### loop関数

各コンポーネントの状態を見て、車体を制御します。**インスタンス生成は原則として絶対にしてはいけません。** 電圧不足による予期しない挙動が発生します。

```c++
void loop() {
    controller->Update();
    controller->Operate();
    delay(10);
}
```
